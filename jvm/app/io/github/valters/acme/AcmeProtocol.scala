/*
 * Copyright 2016 Ringo Wathelet
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.valters.acme

import com.nimbusds.jose.jwk.JWK

import play.api.libs.json.{ Format, JsError, JsPath, JsResult, JsString, JsSuccess, JsValue, Json, Reads, Writes }

/**
  * Defines ACME protocol objects and messages.
  *
  * Reference: Let's Encrypt project at: https://letsencrypt.org/
  *
  * based on draft-ietf-acme-acme-04 (October 31, 2016)
  *
  * For the ACME protocol specification see:
  * https://tools.ietf.org/html/draft-ietf-acme-acme-04
  *
  * This contains the DTOs and relevant constants: for JSON parts
  * please see AcmeJson.
  */
package object AcmeProtocol {

  /** url fragment */
  val DirectoryFragment = "/directory"

  val NonceHeader = "Replay-Nonce"

  //----------------------------------------------------------------------------
  //-----------------supporting elements----------------------------------------
  //----------------------------------------------------------------------------

  /**
    * An AcmeIdentifier encodes an identifier that can
    * be validated by ACME. The protocol allows for different
    * types of identifier to be supported (DNS names, IP
    * addresses, etc.), but currently only supports domain names.
    *
    * @param type  The identifier type, default dns
    * @param value The identifier itself, default "dns"
    */
  final case class AcmeIdentifier(`type`: String = "dns", value: String = "dns") {

    def this(value: String) = this(`type` = "dns", value = value)
  }

  object AcmeIdentifier {
    implicit val fmt = Json.format[AcmeIdentifier]
  }

  /**
    * ACME simple JSON-based structure for encoding signature.
    *
    * @param alg   A token indicating the cryptographic algorithm used to compute the signature
    * @param sig   The signature, base64-encoded.
    * @param nonce A signer-provided random nonce of at least 16 bytes, base64-encoded. (For anti-replay)
    * @param jwk   A JSON Web Key object describing the key used to verify the signature {{I-D.ietf-jose-json-web-key}}.
    */
  case class AcmeSignature(alg: String, sig: String, nonce: String, jwk: JWK)

  /**
    * A recovery client key, a secret key with the server that can be used to recover the client account later.
    *
    * @param client The client’s ECDH public key
    * @param length The length of the derived secret, in octets.
    */
  final case class RecoveryKeyClient(client: JWK, length: Int)

  /**
    * A recovery key generated by the server that can be used to recover the client account later.
    *
    * @param server The server’s ECDH public key
    */
  final case class RecoveryKeyServer(server: JWK)


  /**
    * Error Codes
    */
  sealed trait ErrorCode

  case object badCSR extends ErrorCode

  case object badNonce extends ErrorCode

  case object connection extends ErrorCode

  case object dnssec extends ErrorCode

  case object malformed extends ErrorCode

  case object serverInternal extends ErrorCode

  case object rateLimited extends ErrorCode

  case object tls extends ErrorCode

  case object unauthorized extends ErrorCode

  case object unknownHost extends ErrorCode

  case object invalidEmail extends ErrorCode

  case object unknownError extends ErrorCode


  object ErrorCode {

    /**
      * convert a String value to a ErrorCode case object.
      * NOTE: if the String value is null or the String value does not match, returns unknownError
      *
      * @param value to convert into a ErrorCode case object
      */
    def fromString(value: String): ErrorCode = {
      if (value == null) unknownError
      else {
        value.trim match {
          case "badCSR" => badCSR
          case "badNonce" => badNonce
          case "connection" => connection
          case "dnssec" => dnssec
          case "malformed" => malformed
          case "serverInternal" => serverInternal
          case "tls" => tls
          case "unauthorized" => unauthorized
          case "unknownHost" => unknownHost
          case "rateLimited" => rateLimited
          case "invalidEmail" => invalidEmail
          case _ => unknownError
        }
      }
    }

    val theReads = new Reads[ErrorCode] {
      def reads(json: JsValue): JsResult[ErrorCode] = {
        JsPath.read[String].reads(json).asOpt match {
          case Some(err) => JsSuccess(fromString(err))
          case None => JsSuccess(unknownError)
        }
      }
    }

    val theWrites = new Writes[ErrorCode] {
      def writes(err: ErrorCode) = {
        if (err == null) JsString(unknownError.toString) else JsString(err.toString)
      }
    }

    implicit val fmt: Format[ErrorCode] = Format(theReads, theWrites)
  }

  // the dictionary of all acme error codes and their descriptions
  val errorCodeMap: Map[ErrorCode,String] = Map(
    badCSR -> "The CSR is unacceptable (e.g., due to a short key)",
    badNonce -> "The client sent an unacceptable anti-replay nonce",
    connection -> "The server could not connect to the client to verify the domain",
    dnssec -> "The server could not validate a DNSSEC signed domain",
    malformed -> "The request message was malformed",
    rateLimited -> "There were too many requests of a given type",
    serverInternal -> "The server experienced an internal error",
    tls -> "The server experienced a TLS error during domain verification",
    unauthorized -> "The client lacks sufficient authorization",
    unknownHost -> "The server could not resolve a domain name",
    invalidEmail -> "The provided email for a registration was invalid",
    unknownError -> "unknownError"
  )

  /**
    * resource types that indicate what type of resource the request is addressed to
    */
  sealed trait ResourceType
  case object new_reg extends ResourceType { override def toString() = "new-reg"}
  case object recover_reg extends ResourceType { override def toString() = "recover-reg"}
  case object new_authz extends ResourceType { override def toString() = "new-authz"}
  case object new_cert extends ResourceType { override def toString() = "new-cert"}
  case object revoke_cert extends ResourceType { override def toString() = "revoke-cert"}
  case object reg extends ResourceType { override def toString() = "reg"}
  case object authz extends ResourceType { override def toString() = "authz"}
  case object challenge extends ResourceType { override def toString() = "challenge"}
  case object cert extends ResourceType { override def toString() = "cert"}
  case object key_change extends ResourceType { override def toString() = "key-change"}

  object ResourceType {

    /**
      * convert a String value to a ResourceType case object.
      * NOTE: if the String value is null or the String value does not match, returns reg
      *
      * @param value to convert into a ResourceType case object
      */
    def fromString(value: String): ResourceType = {
      if (value == null) reg
      else {
        value.trim match {
          case "new-reg" => new_reg
          case "recover-reg" => recover_reg
          case "new-authz" => new_authz
          case "new-cert" => new_cert
          case "revoke-cert" => revoke_cert
          case "reg" => reg
          case "authz" => authz
          case "challenge" => challenge
          case "cert" => cert
          case "key-change" => key_change
          case _ => reg
        }
      }
    }

    val theReads = new Reads[ResourceType] {
      def reads(json: JsValue): JsResult[ResourceType] = {
        JsPath.read[String].reads(json).asOpt match {
          case Some(res) => JsSuccess(fromString(res))
          case None => JsSuccess(reg)
        }
      }
    }

    val theWrites = new Writes[ResourceType] {
      def writes(res: ResourceType) = {
        if (res == null) JsString(reg.toString()) else JsString(res.toString)
      }
    }

    implicit val fmt: Format[ResourceType] = Format(theReads, theWrites)
  }

  // the set of all resource types as Strings
  val resourceSet = Set(new_reg.toString(), recover_reg.toString(), new_authz.toString(), new_cert.toString(), revoke_cert.toString(), reg.toString(), authz.toString(), challenge.toString(), cert.toString())

  /**
    * authorization status codes
    */
  sealed trait StatusCode

  case object unknown extends StatusCode
  case object pending extends StatusCode
  case object processing extends StatusCode
  case object valid extends StatusCode
  case object invalid extends StatusCode
  case object revoked extends StatusCode

  object StatusCode {

    /**
      * convert a String value to a StatusCode case object.
      * NOTE: if the String value is null or the String value does not match, returns unknown
      *
      * @param value to convert into a StatusCode case object
      */
    def fromString(value: String): StatusCode = {
      if (value == null) unknown
      else {
        value.trim match {
          case "unknown" => unknown
          case "pending" => pending
          case "processing" => processing
          case "valid" => valid
          case "invalid" => invalid
          case "revoked" => revoked
          case _ => unknown
        }
      }
    }

    val theReads = new Reads[StatusCode] {
      def reads(json: JsValue): JsResult[StatusCode] = {
        JsPath.read[String].reads(json).asOpt match {
          case Some(code) => JsSuccess(fromString(code))
          case None => JsSuccess(unknown)
        }
      }
    }

    val theWrites = new Writes[StatusCode] {
      def writes(err: StatusCode) = {
        err match {
          case `unknown` => JsString(unknown.toString)
          case `pending` => JsString(pending.toString)
          case `processing` => JsString(processing.toString)
          case `valid` => JsString(valid.toString)
          case `invalid` => JsString(invalid.toString)
          case `revoked` => JsString(revoked.toString)
          case _ => JsString(unknown.toString)
        }
      }
    }

    implicit val fmt: Format[StatusCode] = Format(theReads, theWrites)
  }

  sealed trait ErrorType

  /**
    * a generic acme error message.
    *
    * @param type    the acme error code, default "unknownError"
    * @param detail  Typically a URL of a resource containing additional human-readable documentation about the error,
    *                such as advice on how to revise the request or adjust the client
    *                configuration to allow the request to succeed, or documentation
    *                of CA issuance policies that describe why the request cannot be fulfilled
    * @param title A short, human-readable summary of the problem
    * @param status The HTTP status code generated by the origin server for this occurrence of the problem.
    * @param instance A URI reference that identifies the specific occurrence of the problem.
    * @param error error description, a token from the set of error types, indicating what type of error occurred
    */
  final case class AcmeErrorMessage(`type`: ErrorCode = unknownError, detail: String,
                                    title: Option[String] = None, status: Option[Int] = None, instance: Option[String] = None,
                                    error: Option[String] = None) extends ErrorType

  object AcmeErrorMessage {
    implicit val fmt = Json.format[AcmeErrorMessage]
  }

  /**
    * determine if the input json message is a AcmeErrorMessage based on testing its "type" field
    *
    * @param msg the input json message to test
    * @return true if the input json message is a AcmeErrorMessage else false
    */
  def isAcmeErrorType(msg: JsValue): Boolean = {
    (msg \ "type").asOpt[String] match {
      case Some(t) => errorCodeMap.keySet.contains(ErrorCode.fromString(t))
      case None => false
    }
  }

  /**
    * determine if the input json message is a ChallengeResponseType based on testing its "type" field
    *
    * @param msg the input json message to test
    * @return true if the input json message is a ChallengeResponseType else false
    */
  def isChallengeResponseType(msg: JsValue): Boolean = {
    (msg \ "type").asOpt[String] match {
      case Some(t) => challengeTypeSet.contains(t)
      case None => false
    }
  }

  /**
    * determine if the input json message is a RequestType based on testing its "resource" field
    *
    * @param msg the input json message to test
    * @return true if the input json message is a RequestType else false
    */
  def isRequestType(msg: JsValue): Boolean = {
    (msg \ "resource").asOpt[String] match {
      case Some(t) => resourceSet.contains(t)
      case None => false
    }
  }

  //----------------------------------------------------------------------------
  //-----------------Server Challenge Type---------------------------------------------
  //----------------------------------------------------------------------------

  val simple_http = "http-01"
  val tls_sni = "tls-sni-01"
  val dns = "dns-01"
  val proofOfPossession = "proofOfPossession"

  // acme challenge types set
  val challengeTypeSet = Set(simple_http, tls_sni, dns, proofOfPossession)

  /**
    * Simple HTTPS validation challenge
    *
    * @param type     type of the challenge, "simpleHttps"
    * @param uri     The URI to which a response can be posted.
    * @param tls     Transport Layer Security (TLS) option
    * @param token    The value to be used in generation of validation JWS.
    * @param status    The status of this authorization. Possible values are: “unknown”, “pending”, “processing”, “valid”, “invalid” and “revoked”.
    * @param validated The time at which this challenge was completed by the server,
    * @param error possible error
    */
  final case class ChallengeType(`type`: String = simple_http,
                                        uri: String, token: String, tls: Option[Boolean] = Some(false),
                                        status: Option[StatusCode] = None, validated: Option[String] = None,
                                        error: Option[AcmeErrorMessage] = None)

  /** Indicate to ACME server that we would like to proceed with HTTP challenge */
  final case class AcceptChallengeType(`type`: String = simple_http, resource: String = "challenge", keyAuthorization: String, tls: Option[Boolean] = Some(false) )

  //----------------------------------------------------------------------------
  //-----------------Request Type-----------------------------------------------
  //----------------------------------------------------------------------------

  /**
    * an acme request message type
    */
  sealed trait RequestType {
    val resource: ResourceType
  }

  /**
    * a registration request.
    *
    * @param resource       The type of resource the request is addressed to, specifically "new-reg"
    * @param key            The public key of the account key pair, encoded as a JSON Web Key object
    * @param recoveryKey    The client recoveryKey
    * @param contact        An array of URIs that the server can use to contact the client for issues related to this authorization.
    * @param agreement      A URI referring to a subscriber agreement or terms of service provided by the server.
    * @param authorizations A URI from which a list of authorizations granted to this account can be fetched via a GET request.
    * @param certificates   A URI from which a list of certificates issued for this account can be fetched via a GET request.
    */
  final case class RegistrationRequest(resource: ResourceType, key: Option[JWK] = None,
                                       recoveryKey: Option[RecoveryKeyClient] = None,
                                       contact: Option[Array[String]] = None,
                                       agreement: Option[String] = None,
                                       authorizations: Option[String] = None,
                                       certificates: Option[String] = None) extends RequestType {

    /**
      * a new account ("new-reg") request
      * @param contact An array of URIs that the server can use to contact the client for issues related to this authorization.
      */
    def this(contact: Array[String]) = this(resource = new_reg, contact = Some(contact))

  }

  /**
    * MAC-based recovery request
    *
    * @param resource The type of resource the request is addressed to, specifically "recover-reg"
    * @param method   The string “mac”
    * @param base     The URI for the registration to be recovered.
    * @param mac      A JSON-formatted JWS object using an HMAC algorithm, whose payload is the JWK representation
    *                 of the public key of the new account key pair.
    */
  final case class MACBasedRecoveryRequest(resource: ResourceType = recover_reg, method: String = "mac",
                                           base: String, mac: JWK) extends RequestType

  object MACBasedRecoveryRequest {
//    implicit val fmt = Json.format[MACBasedRecoveryRequest]
  }

  /**
    * contact-based recovery request
    *
    * @param resource The type of resource the request is addressed to, specifically "recover-reg"
    * @param method   The string “contact”
    * @param base     The URI for the registration to be recovered.
    * @param contact  An array of URIs that the server can use to contact the client
    */
  final case class ContactBasedRecoveryRequest(resource: ResourceType = recover_reg, method: String = "contact",
                                               base: String, contact: Array[String]) extends RequestType

  object ContactBasedRecoveryRequest {
    implicit val fmt = Json.format[ContactBasedRecoveryRequest]
  }

  /**
    * a polling status request by the client.
    * @param resource The type of resource the request is addressed to, default "reg"
    */
  final case class StatusRequest(resource: ResourceType = reg) extends RequestType

  object StatusRequest {
    implicit val fmt = Json.format[StatusRequest]
  }

  /**
    * An Authorization Request
    *
    * @param resource   The type of resource the request is addressed to, specifically "new-authz"
    * @param identifier The identifier that the account is authorized to represent
    */
  final case class AuthorizationRequest(resource: ResourceType = new_authz, identifier: AcmeIdentifier) extends RequestType

  object AuthorizationRequest {
    implicit val fmt = Json.format[AuthorizationRequest]
  }

  /**
    * A certificate issuance request
    *
    * @param resource The type of resource the request is addressed to, specifically "new-cert"
    * @param csr      A CSR encoding the parameters for the certificate being requested.
    */
  final case class CertificateRequest(resource: ResourceType = new_cert, csr: String) extends RequestType

  object CertificateRequest {
    implicit val fmt = Json.format[CertificateRequest]
  }

  /**
    * A certificate revocation request
    *
    * @param resource  The type of resource the request is addressed to, specifically "revoke_cert"
    * @param certificate the certificate to revoke
    */
  final case class RevocationRequest(resource: ResourceType = revoke_cert, certificate: String) extends RequestType

  object RevocationRequest {
    implicit val fmt = Json.format[RevocationRequest]
  }

  //----------------------------------------------------------------------------
  //-----------------Challenge Client Response Type------------------------------------
  //----------------------------------------------------------------------------

  /**
    * challenge response type sent by the client
    */
  sealed trait ChallengeResponseType

  /**
    * response by the client to the server simple HTTPS challenge
    *
    * @param type type of the response, "simpleHttps"
    * @param tls  Transport Layer Security (TLS) option
    * @param error possible error
    */
  final case class SimpleHTTPSResponse(`type`: String = simple_http, tls: Option[Boolean] = Some(true),
                                       error: Option[AcmeErrorMessage] = None) extends ChallengeResponseType

  /**
    * response by the client to the server dvsni challenge
    *
    * @param type       type of the challenge, "dvsni"
    * @param validation The JWS object computed with the validation object and the account key
    * @param error possible error
    */
  final case class DVSNIResponse(`type`: String = tls_sni, validation: JWK,
                                 error: Option[AcmeErrorMessage] = None) extends ChallengeResponseType

  /**
    * response by the client to the server dns challenge
    *
    * @param type            type of the response, "dns"
    * @param clientPublicKey the client publicKey
    * @param validation      The JWS object computed with the validation object and the account key
    * @param error possible error
    */
  final case class DNSResponse(`type`: String = dns, clientPublicKey: JWK, validation: JWK,
                               error: Option[AcmeErrorMessage] = None) extends ChallengeResponseType

  /**
    * response by the client to the server proofOfPossession challenge
    *
    * @param type          type of the response, "proofOfPossession"
    * @param identifiers   A list of identifiers for which the holder of the prior key authorizes the new key
    * @param accountKey    The client’s account public key
    * @param authorization The validation JWS
    * @param error possible error
    */
  final case class ProofOfPossessionResponse(`type`: String = proofOfPossession, identifiers: AcmeIdentifier,
                                             accountKey: JWK, authorization: JWK,
                                             error: Option[AcmeErrorMessage] = None) extends ChallengeResponseType

  //----------------------------------------------------------------------------
  //-----------------Server Response Type----------------------------------------------
  //----------------------------------------------------------------------------

  /**
    * acme response constants
    */
  val recoveryToken = "recoveryToken"
  val recoveryContact = "recoveryContact"

  /**
    * an acme response type
    */
  sealed trait ResponseType

  /**
    * a recovery token client response
    *
    * @param type  type of the response, "recoveryToken
    * @param token The recovery token provided by the server with an authorize message.
    * @param error possible error
    */
  final case class RecoveryTokenResponse(`type`: String = recoveryToken, token: Option[String] = None,
                                         error: Option[AcmeErrorMessage] = None) extends ResponseType

  object RecoveryTokenResponse {
    implicit val fmt = Json.format[RecoveryTokenResponse]
  }

  /**
    * a recovery contact response
    *
    * @param type  type of the response, "recoveryContact"
    * @param token If the user transferred a token from a contact email or call into the client software, the client sends it here.
    * @param error possible error
    */
  final case class RecoveryContactResponse(`type`: String = recoveryContact, token: Option[String] = None,
                                           error: Option[AcmeErrorMessage] = None) extends ResponseType

  object RecoveryContactResponse {
    implicit val fmt = Json.format[RecoveryContactResponse]
  }

  /**
    * a certificate issuance response message
    *
    * @param certificate The issued certificate, as a base64-encoded DER certificate.
    */
  final case class Certificate(certificate: String) extends ResponseType

  object Certificate {

    val theReads = new Reads[Certificate] {
      def reads(json: JsValue): JsResult[Certificate] = {
        JsPath.read[String].reads(json).asOpt match {
          case Some(str) => JsSuccess(Certificate(str))
          case None => JsError("could not process jsValue: " + json + " into a certificate")
        }
      }
    }

    val theWrites = new Writes[Certificate] {
      def writes(cert: Certificate) = JsString(cert.certificate)
    }

    implicit val fmt: Format[Certificate] = Format(theReads, theWrites)
  }

  /**
    * An ACME authorization object represents the server’s authorization for an account to represent an identifier.
    *
    * @param identifier   The identifier that the account is authorized to represent
    * @param challenges   The challenges that the client needs to fulfill in order to prove possession of the identifier (for pending authorizations).
    * @param combinations A collection of sets of challenges, each of which would be sufficient to prove possession of the identifier.
    * @param status       The status of this authorization. Possible values are: “unknown”, “pending”, “processing”, “valid”, “invalid” and “revoked”.
    *                     If this field is missing, then the default value is “pending”.
    * @param expires      The date after which the server will consider this authorization invalid, encoded in the format specified in RFC 3339
    * @param error possible error
    */
  final case class AuthorizationResponse(identifier: AcmeIdentifier,
                                         challenges: List[ChallengeType] = List.empty,
                                         combinations: Option[Array[Array[Int]]] = None,
                                         status: Option[StatusCode] = Some(pending),
                                         expires: Option[String] = None,
                                         error: Option[AcmeErrorMessage] = None) extends ResponseType {

    /**
      * A pending authorization server response.
      *
      * @param identifier   The identifier that the account is authorized to represent
      * @param challenges   The challenges that the client needs to fulfill in order to prove possession of the identifier (for pending authorizations).
      * @param combinations A collection of sets of challenges, each of which would be sufficient to prove possession of the identifier.
      */
    def this(identifier: AcmeIdentifier, challenges: List[ChallengeType], combinations: Array[Array[Int]]) =
      this(identifier, challenges, Some(combinations), Some(pending), None, None)

  }

  /**
    * An ACME registration resource represents a set of metadata associated to an account key pair.
    *
    * @param key            The public key of the account key pair, encoded as a JSON Web Key object
    * @param contact        An array of URIs that the server can use to contact the client for issues related to this authorization.
    * @param recoveryKey    The server recovery key
    * @param agreement      A URI referring to a subscriber agreement or terms of service provided by the server.
    * @param authorizations A URI from which a list of authorizations granted to this account can be fetched via a GET request.
    * @param certificates   A URI from which a list of certificates issued for this account can be fetched via a GET request.
    * @param error possible error
    */
  final case class RegistrationResponse( key: Option[JWK] = None, contact: Option[Array[String]] = None,
                                        recoveryKey: Option[RecoveryKeyServer] = None,
                                        agreement: Option[String] = None,
                                        authorizations: Option[String] = None,
                                        certificates: Option[String] = None,
                                        error: Option[AcmeErrorMessage] = None ) extends ResponseType

  /**
   * @param uri uri that we will visit indicating that we agree to terms
   * @param agreement url terms-of-service that we will say we agree to. if None, then ToS already has been agreed to and we don't need to agree again
   */
  final case class SimpleRegistrationResponse( uri: String, agreement: Option[String] ) extends ResponseType

  /**
    * directory is a JSON dictionary whose keys are the “resource” values and
    * whose values are the URIs used to accomplish the corresponding function.
    *
    * @param directory map of resource -> URI
    */
  final case class Directory(directory: Map[ResourceType, String]) extends ResponseType {

    /** shortcut */
    def get( key: ResourceType ): String = directory(key)

  }

  /**
   * Server is cut down only to URIs that we use.
   */
  case class AcmeServer( dir: String, newReg: String, newAuthz: String, newCert: String ) {
    def this( dir: String, directory: AcmeProtocol.Directory ) = {
      this( dir, directory.get( AcmeProtocol.new_reg ),
          directory.get( AcmeProtocol.new_authz ),
          directory.get( AcmeProtocol.new_cert ) )
    }
  }

}
